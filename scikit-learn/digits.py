# -*- coding: utf-8 -*-

# 下準備

## データセットモジュールのインポート


from sklearn import datasets

# digitsというデータセットをロードします。
digits = datasets.load_digits()


# これはコードとして書式設定されます


## データを表示する


print(digits.data)
print('次元：', digits.data.ndim)

print(digits.data.shape)

print(digits.target)

digits.images[2]

"""## データを画像として描画する"""

from sklearn import datasets
import matplotlib.pyplot as plt

# 3番目の数字を表示します
plt.imshow(digits.images[2], cmap=plt.cm.gray_r, interpolation='nearest')
plt.show()

# 例えば31番(配列の要素は0から数えますので、31番目は30で取り出します)
plt.imshow(digits.images[30], cmap=plt.cm.gray_r, interpolation='nearest')
plt.show()

"""## cmap(color map)を使う"""

# 任意の数字を表示する（例えば48番）
plt.imshow(digits.images[47], cmap='plasma', interpolation='bicubic')
plt.show()

"""## 複数データを描画する"""

import numpy as np

# 数字を表示するための行と列の数
# 行
ROWS_COUNT = 4
# 列
COLUMNS_COUNT = 4
#
DIGIT_GRAPH_COUNT = ROWS_COUNT * COLUMNS_COUNT
# データオブジェクト保持用
subfig = []
# x軸データ
x = np.linspace(-1, 1, 10)

# figureオブジェクト作成サイズを決めます
fig = plt.figure(figsize=(12, 9))

#
for i in range(1, DIGIT_GRAPH_COUNT + 1):
    # 順序i番目のsubfigに追加します
    subfig.append(fig.add_subplot(ROWS_COUNT, COLUMNS_COUNT, i))
    # y軸データ(n次式)
    y = x ** i
    subfig[i - 1].imshow(digits.images[i], interpolation='bicubic', cmap='viridis')

# グラフ間の横とたての隙間の調整
fig.subplots_adjust(wspace=0.3, hspace=0.3)
plt.show()

"""## 手書き数字データセットを三次元の空間で見る"""

from sklearn import decomposition
from mpl_toolkits.mplot3d import Axes3D

# 手書き数字のデータをロードし、変数digitsに格納
digits = datasets.load_digits()

# 特徴量のセットを変数Xに、ターゲットを変数yに格納
all_features = digits.data
teacher_labels = digits.target

"""（0-9）数字データの色を指定する関数です。"""


def getcolor(color):
    if color == 0:
        return 'red'
    elif color == 1:
        return 'orange'
    elif color == 2:
        return 'yellow'
    elif color == 3:
        return 'greenyellow'
    elif color == 4:
        return 'green'
    elif color == 5:
        return 'cyan'
    elif color == 6:
        return 'blue'
    elif color == 7:
        return 'navy'
    elif color == 8:
        return 'purple'
    else:
        return 'black'


# 主成分分析を行って、3次元へと次元を減らします
pca = decomposition.PCA(n_components=3)

# 主成分分析により、64次元のall_featuresを3次元のthree_featuresに変換
three_features = pca.fit_transform(all_features)

# figureオブジェクト作成サイズを決めます
fig = plt.figure(figsize=(12, 9))
#
subfig = fig.add_subplot(111, projection='3d')
# 教師データ(teacher_labels)に対応する色のリストを用意
colors = list(map(getcolor, teacher_labels))

# 三次元空間へのデータの色付き描画を行う
subfig.scatter(three_features[:, 0], three_features[:, 1], three_features[:, 2], s=50, c=colors, alpha=0.3)

# 描画したグラフを表示
plt.show()

"""# 調理手順

## 分類器をインポートする
"""

# 分類機(Classifiers) SVMとmetricsをインポートします
from sklearn import svm, metrics

# 画像ファイルは同じサイズでなければいけません
images_and_labels = list(zip(digits.images, digits.target))
print('教師データ：', digits.target)

# figureオブジェクト作成サイズを決めます
fig = plt.figure(figsize=(12, 9))
#
for index, (image, label) in enumerate(images_and_labels[: 8]):
    plt.subplot(2, 4, index + 1)
    # 座標軸を表示しない
    plt.axis('off')
    plt.imshow(image, cmap=plt.cm.gray_r, interpolation='nearest')
    plt.title('Train Data: %i' % label)

# データの個数
num_samples = len(digits.images)
print(num_samples)

"""## データを再構成"""

print(digits.images.shape)

data = digits.images.reshape((num_samples, -1))

print(data)

print(data.shape)

import sklearn.svm as svm

"""## 分類機（SVC）の作成"""

model = svm.SVC(gamma=0.001)

# 学習用の学習データと教師データ
train_features = data[: num_samples // 2]
train_teacher_labels = digits.target[: num_samples // 2]
# 検証用の学習データと教師データ
test_feature = data[num_samples // 2:]
test_teacher_labels = digits.target[num_samples // 2:]

# 最初の半分のデータを学習データとして、学習させます。
model.fit(train_features, train_teacher_labels)

expected = test_teacher_labels
#
predicted = model.predict(test_feature)

from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report

print("分類機が分類した結果 %s: \n %s \n" % (model, classification_report(expected, predicted)))
print("コンフュージョンマトリックス:\n %s" % confusion_matrix(expected, predicted))

"""## 検証とグラフ"""

# figureオブジェクト作成サイズを決めます
fig = plt.figure(figsize=(12, 9))
#
digits_and_predictions = list(zip(digits.images[num_samples // 2:], predicted))
for index, (image, prediction) in enumerate(digits_and_predictions[: 4]):
    plt.subplot(2, 4, index + 5)
    plt.imshow(image, cmap='PiYG', interpolation='bicubic')
    plt.title('Prediction: %i' % prediction)

plt.show()
# -*- coding: utf-8 -*-
"""04-04(scikit-learn digits).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pYG5kbv1UnvrhuzBVU-IcVtdCDdVd_En

# 下準備

## データセットモジュールのインポート
"""

from sklearn import datasets

# digitsというデータセットをロードします。
digits = datasets.load_digits()

"""```
# これはコードとして書式設定されます
```

## データを表示する
"""

print(digits.data)
print('次元：', digits.data.ndim)

print(digits.data.shape)

print(digits.target)

digits.images[2]

"""## データを画像として描画する"""

from sklearn import datasets
import matplotlib.pyplot as plt

# 3番目の数字を表示します
plt.imshow(digits.images[2], cmap=plt.cm.gray_r, interpolation='nearest')
plt.show()

# 例えば31番(配列の要素は0から数えますので、31番目は30で取り出します)
plt.imshow(digits.images[30], cmap=plt.cm.gray_r, interpolation='nearest')
plt.show()

"""## cmap(color map)を使う"""

# 任意の数字を表示する（例えば48番）
plt.imshow(digits.images[47], cmap='plasma', interpolation='bicubic')
plt.show()

"""## 複数データを描画する"""

import numpy as np

# 数字を表示するための行と列の数
# 行
ROWS_COUNT = 4
# 列
COLUMNS_COUNT = 4
#
DIGIT_GRAPH_COUNT = ROWS_COUNT * COLUMNS_COUNT
# データオブジェクト保持用
subfig = []
# x軸データ
x = np.linspace(-1, 1, 10)

# figureオブジェクト作成サイズを決めます
fig = plt.figure(figsize=(12, 9))

#
for i in range(1, DIGIT_GRAPH_COUNT + 1):
    # 順序i番目のsubfigに追加します
    subfig.append(fig.add_subplot(ROWS_COUNT, COLUMNS_COUNT, i))
    # y軸データ(n次式)
    y = x ** i
    subfig[i - 1].imshow(digits.images[i], interpolation='bicubic', cmap='viridis')

# グラフ間の横とたての隙間の調整
fig.subplots_adjust(wspace=0.3, hspace=0.3)
plt.show()

"""## 手書き数字データセットを三次元の空間で見る"""

from sklearn import decomposition
from mpl_toolkits.mplot3d import Axes3D

# 手書き数字のデータをロードし、変数digitsに格納
digits = datasets.load_digits()

# 特徴量のセットを変数Xに、ターゲットを変数yに格納
all_features = digits.data
teacher_labels = digits.target

"""（0-9）数字データの色を指定する関数です。"""


def getcolor(color):
    if color == 0:
        return 'red'
    elif color == 1:
        return 'orange'
    elif color == 2:
        return 'yellow'
    elif color == 3:
        return 'greenyellow'
    elif color == 4:
        return 'green'
    elif color == 5:
        return 'cyan'
    elif color == 6:
        return 'blue'
    elif color == 7:
        return 'navy'
    elif color == 8:
        return 'purple'
    else:
        return 'black'


# 主成分分析を行って、3次元へと次元を減らします
pca = decomposition.PCA(n_components=3)

# 主成分分析により、64次元のall_featuresを3次元のthree_featuresに変換
three_features = pca.fit_transform(all_features)

# figureオブジェクト作成サイズを決めます
fig = plt.figure(figsize=(12, 9))
#
subfig = fig.add_subplot(111, projection='3d')
# 教師データ(teacher_labels)に対応する色のリストを用意
colors = list(map(getcolor, teacher_labels))

# 三次元空間へのデータの色付き描画を行う
subfig.scatter(three_features[:, 0], three_features[:, 1], three_features[:, 2], s=50, c=colors, alpha=0.3)

# 描画したグラフを表示
plt.show()

"""# 調理手順

## 分類器をインポートする
"""

# 分類機(Classifiers) SVMとmetricsをインポートします
from sklearn import svm, metrics

# 画像ファイルは同じサイズでなければいけません
images_and_labels = list(zip(digits.images, digits.target))
print('教師データ：', digits.target)

# figureオブジェクト作成サイズを決めます
fig = plt.figure(figsize=(12, 9))
#
for index, (image, label) in enumerate(images_and_labels[: 8]):
    plt.subplot(2, 4, index + 1)
    # 座標軸を表示しない
    plt.axis('off')
    plt.imshow(image, cmap=plt.cm.gray_r, interpolation='nearest')
    plt.title('Train Data: %i' % label)

# データの個数
num_samples = len(digits.images)
print(num_samples)

"""## データを再構成"""

print(digits.images.shape)

data = digits.images.reshape((num_samples, -1))

print(data)

print(data.shape)

import sklearn.svm as svm

"""## 分類機（SVC）の作成"""

model = svm.SVC(gamma=0.001)

# 学習用の学習データと教師データ
train_features = data[: num_samples // 2]
train_teacher_labels = digits.target[: num_samples // 2]
# 検証用の学習データと教師データ
test_feature = data[num_samples // 2:]
test_teacher_labels = digits.target[num_samples // 2:]

# 最初の半分のデータを学習データとして、学習させます。
model.fit(train_features, train_teacher_labels)

expected = test_teacher_labels
#
predicted = model.predict(test_feature)

from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report

print("分類機が分類した結果 %s: \n %s \n" % (model, classification_report(expected, predicted)))
print("コンフュージョンマトリックス:\n %s" % confusion_matrix(expected, predicted))

"""## 検証とグラフ"""

# figureオブジェクト作成サイズを決めます
fig = plt.figure(figsize=(12, 9))
#
digits_and_predictions = list(zip(digits.images[num_samples // 2:], predicted))
for index, (image, prediction) in enumerate(digits_and_predictions[: 4]):
    plt.subplot(2, 4, index + 5)
    plt.imshow(image, cmap='PiYG', interpolation='bicubic')
    plt.title('Prediction: %i' % prediction)

plt.show()
